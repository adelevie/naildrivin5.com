<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Naildrivin' &#10106;]]></title>
  <link href="http://www.naildrivin5.com/atom.xml" rel="self"/>
  <link href="http://www.naildrivin5.com/"/>
  <updated>2013-09-27T08:55:10-04:00</updated>
  <id>http://www.naildrivin5.com/</id>
  <author>
    <name><![CDATA[David Bryant Copeland]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[&dagger; An Introvert Goes to Dinner]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/09/27/an-introvert-goes-to-dinner.html"/>
    <updated>2013-09-27T08:52:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/09/27/an-introvert-goes-to-dinner</id>
    <content type="html"><![CDATA[<p>I&#8217;m trying out <a href="http://www.medium.com">Medium</a> as a place to do non-technical writing, mostly to keep this blog&#8217;s topic focused
on technology.  I won&#8217;t cross-post everything here, but this is my first one, <a href="https://medium.com/architecting-a-life/3c66705aac17">An Introvert Goes to Dinner</a>.  Excerpt:</p>

<blockquote><p>I actually enjoy solo trips like this. It&#8217;s a chance to be as alone as possible: I&#8217;m in a city were I don&#8217;t know anyone, typically with a lot of free time outside of whatever reason brings me to said city. I know I won&#8217;t have to talk to anyone.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&dagger; My Book is On Sale]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/09/13/my-book-is-on-sale.html"/>
    <updated>2013-09-13T11:08:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/09/13/my-book-is-on-sale</id>
    <content type="html"><![CDATA[<p>My book, <a href="http://theseniorsoftwareengineer.com">The Senior Software Engineer</a>, is on sale today for only <strong>$10!</strong>.  Happy Programmer&#8217;s Day!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromebook Keyboard Slightly Innovative]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/09/06/chromebook-keyboard-slightly-innovative.html"/>
    <updated>2013-09-06T17:43:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/09/06/chromebook-keyboard-slightly-innovative</id>
    <content type="html"><![CDATA[<p>Brief follow up to my <a href="http://www.naildrivin5.com/blog/2013/08/29/a-real-keyboard-for-programmers.html">A real keyboard for programmers</a> post, I got a
<a href="http://www.google.com/intl/en/chrome/devices/">Chromebook</a> yesterday and the keyboard, while sporting the same layout as most other computers, actually
is better designed for what the Chromebook does.</p>

<p>Namely, it has no function keys, instead using them for browser navigation, window management, and hardware controls.  Most amazingly, though, it has no
Caps Lock, instead making it a Search key, which makes sense.  It&#8217;s a big key in a very prominent spot and Search is what Google wants you to do.</p>

<p><img src="http://www.naildrivin5.com/images/chromebook_keyboard.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A real keyboard for programmers?]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/08/29/a-real-keyboard-for-programmers.html"/>
    <updated>2013-08-29T07:58:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/08/29/a-real-keyboard-for-programmers</id>
    <content type="html"><![CDATA[<p>Jeff Atwood (AKA codinghorror), <a href="http://www.codinghorror.com/blog/2013/08/the-code-keyboard.html">introduced a new computer keyboard</a>, produced by WASD, called <a href="http://codekeyboards.com/">the CODE keyboard</a>:</p>

<blockquote><p>I told him that the state of keyboards was unacceptable to me as a geek, and I proposed a partnership wherein I was willing to work with him to do whatever it takes to produce a truly great mechanical keyboard.</p></blockquote>

<p>Jeff is heralding this as a &#8220;truly great mechanical keyboard&#8221;.  I was very eager to see what such a beast looked like.  Here it
is:</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/5/57/ModelM.jpg" title="" ></p>

<p>Oh wait, sorry, that&#8217;s the original 101-key version of the IBM PC Keyboard, introduced in 1985.  How&#8217;d that get there?  It&#8217;s been
almost thirty years, so the CODE keyboard must be awesome, right?</p>

<!-- more -->


<p><img src="http://codekeyboards.com/img/code-34-right.jpg"></p>

<p>Hmmm.  How can a truly great keyboard still have a &#8220;Scroll Lock&#8221; key?  And what is that &#8220;Print Screen&#8221; key doing there?!  It even comes with a PS/2 adapter!</p>

<p>Aesthetically, this keyboard doesn&#8217;t do anything for me.  Between the haphazard typography and silly Windows &#8220;context menu&#8221; icon,
  I find it pretty ugly.  And no Bluetooth.</p>

<p>Let&#8217;s look deeper at the design, though.  What does it tell us?  This design has been around for thirty years, and here&#8217;s what it
has to say:</p>

<ul>
<li>Hitting &#8220;space&#8221; is the most important thing you could ever do.</li>
<li>Caps Lock and Enter are pretty important and of equal importance - they are the second easiest keys to hit outside of the home
keys.</li>
<li>Letters are more important than numbers, as numbers are farther away from the home position.</li>
<li>Control, Alt, &#8220;Meta&#8221;/Windows, and Shift are all more important than numbers (they are an equal distance away, but have much larger keys).</li>
<li>Alt is the most important modifier - it&#8217;s right where your thumbs are, making it easy to hold down while typing other things.</li>
<li>Tab and Backslash are of equal importance, and are more important than most keys.</li>
<li>Print Screen, Scroll Lock, Pause, Home, End, Page Up, Page Down, Insert, Delete and the arrow keys are all of equal importance,
but lesser than the alphanumerics and modifiers as they are set off to the right.</li>
<li>Analphabetics like &#8220;!&#8221;, &#8220;%&#8221;, and &#8220;{&#8221; are least important, because they require the shift key to enter. &#8220;+&#8221; and &#8220;~&#8221; are probably
the least relevant of these, because they are the most difficult to type: you must use Shift and your pinky, and you have to stretch for them.</li>
</ul>


<p>How much of this is actually true of writing prose?  Of writing code? I would argue that very little of it is correct.  At least
on a Mac, the location of &#8220;Alt&#8221; (called &#8220;Command&#8221;) makes sense - it&#8217;s the modifier for keyboard shortcuts.  On Windows, it&#8217;s
&#8220;Control&#8221;, and requires pinky contortions (which might be why a lot of developers map Caps Lock to Control).  Caps Lock has no
place on any keyboard.</p>

<p>There haven&#8217;t been a ton of innovations in the world of text entry over the years (at least not for writing prose or code - it&#8217;s
all been focused on text message).  There&#8217;s a smattering of &#8220;ergonomic&#8221; keyboards
some of which provide more &#8220;thumb keys&#8221;, but in general, this is the same keyboard that&#8217;s existed for the majority of our lives.  Even
alternate layouts like Dvorak keep most things they same - they just shuffle around the letters.</p>

<p>My personal favorite is the Apple keyboard, as it&#8217;s the same for external and laptop.  It bears many similarities to the classic
101 key layout, but has evolved a bit:</p>

<p><img src="http://images.apple.com/keyboard/images/hero_2.jpg"></p>

<p>Here:</p>

<ul>
<li>Stupid keys like Page Up, Scroll Lock, and Insert are gone.  They have no place in modern computing.</li>
<li>Backslash is shrunk to its rightful size.</li>
<li>Function keys are half-height to denote their unimportance, but are closer to the home position for ease of use (they also default to their alternate meanings - I&#8217;m much more likely to adjust volume than type F12).</li>
<li>The arrow keys are still close at hand, but use half-height keys to signify their lack of importance.</li>
</ul>


<p>This keyboard is classic Apple design in that it eliminates anachronistic features and is nice to look at.</p>

<p>But, it&#8217;s still basically the same keyboard as the CODE, which is the same keyboard that shipped with the first IBM PC.</p>

<h2>A better writing keyboard</h2>

<p>The current layout actually isn&#8217;t bad for writing prose (which isn&#8217;t surprising since it is an evolution of early mechanical keyboards). The letters are where you need them, with commas and periods close at hand.</p>

<p>The symbols next most-frequently needed are the exclamation mark, dash, and parenthesis.
They are all ill-placed in this layout, being far away from the home keys, while more convenient locations are taken up by the rarely-needed caret, ampersand, and asterisk.  I&#8217;d bump the parenthesis over one, putting the asterisk on the &#8220;0&#8221;, swap the exclamation mark with the ampersand, and finally, exchange the carat for the dash.</p>

<p>I&#8217;d also put the &#8220;Shift&#8221; key where &#8220;Alt&#8221; is (or perhaps divide up the space bar to allow shifting), because Shift is the
most-needed modifier when writing. I could also see a case for having the right &#8220;Alt&#8221; be a different modifier to allow accented and other adorned characters.</p>

<p>Where things get interesting is when you consider writing source code.</p>

<h2>A better coding keyboard</h2>

<p>Famously, vi was developed on a computer using an ADM3A terminal, which had this keyboard:</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/KB_Terminal_ADM3A.svg/1000px-KB_Terminal_ADM3A.svg.png"></p>

<p>Notice where the arrow keys are?  Also notice what symbol is on the &#8220;Home&#8221; key?  Finally, do you see how convenient
the &#8220;@&#8221; key is to your right pinky (that&#8217;s the &#8220;execute macro&#8221; command in vi)? I find this fascinating.</p>

<h2>The Chicken and The Egg</h2>

<p>Here&#8217;s the keyboard of a Datapoint 3300, a terminal introduced in 1969 and could have easily been used in the development of the
&#8220;B&#8221; programming language, a precursor to C:</p>

<p><img src="http://www.naildrivin5.com/images/datapoint_3300_keyboard.png"></p>

<p>I&#8217;m not sure how one would enter curly-braces, but look at the positioning of keys for important symbols in C.  The parenthesis
are a bit more convienient, and the square brackets couldn&#8217;t be more at-hand, located as modified versions of M and K.  Note also
that &#8220;plus&#8221; is in a much nicer place—right under your pinky—while the asterisk is in a decent place for right-handers.</p>

<p>The 3300&#8217;s successor, the Datapoint 2200, has a bit of an odder layout, with the brackets and braces in a fairly strange position.</p>

<p><img src="http://www.naildrivin5.com/images/datapoint_2200_keyboard.png"></p>

<p>It&#8217;s hard to say if a keyboard influences language design or follows it.  Here&#8217;s the layout of the IBM 3279 terminal, in use in
the late 70&#8217;s, and you can be sure a <em>lot</em> of C code was written on this thing, just look at where the braces are!</p>

<p><img class="left" src="http://www.naildrivin5.com/images/keyboard_closeup.png" width="500"></p>

<p>It&#8217;s actually perfect for a curly-brace language.  The opening brace is a short right-pinky move away, with the closing
brace merely requiring a shift - a very easy move for right-handers.</p>

<p>Further, notice how easy it is to get to the other important symbols. The ampersand and asterisk—symbols crucial for dealing
with pointers—couldn&#8217;t be easier to access without displacing letters or numbers.</p>

<p>And here&#8217;s the keyboard of an early LISP machine:</p>

<p><img src="http://www.naildrivin5.com/images/lisp_machine_keyboard.png"></p>

<p>Notice how easy and juicy those parenthesis keys are (they are next to the &#8220;P&#8221; but also in their traditional location - the best of both worlds)?  And given the importance of the single quote, notice how convenient it is?  Of course, single quote has been in that place on a lot of old keyboards - perhaps it influenced the design of LISP?  It&#8217;s hard to say.</p>

<p>What about modern languages?</p>

<h2>A keyboard for modern languages</h2>

<p>A front-end developer is probably tired of hitting &#8220;Shift&#8221; to create HTML tags and JavaScript functions, and has probably hit the &#8220;plus&#8221; key way too often in search of the more useful dash (often used in CSS class names).</p>

<p>For me, typing a plus sign is fraught with typos, as is reaching for the exclamation point with my left hand.  In Ruby, a language that makes heavy use of the colon, I&#8217;m hitting &#8220;Shift&#8221; a lot, but the backslash key—much more rarely needed—couldn&#8217;t be more easy to get to.  Further, Ruby uses <code>snake_case</code> (which requires the shift key to access the underscore), and relies on hashes (created by curly braces) much more frequently than most languages<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>So, do I need a Ruby keyboard?  Would I even have enough <em>fingers</em> to use a Scala keyboard?</p>

<p>What would a programming language look like designed for our current thirty-year-old keyboard design?</p>

<h2>A language for modern keyboards</h2>

<ul>
<li>Perhaps carat is a better negation operator than the exclamation mark.</li>
<li>Perhaps argument lists and collection literals would all use square brackets.</li>
<li>Perhaps identifiers could have dashes in them.</li>
<li>Perhaps symbols created with Command/Option modifiers would be useful - many of them would be easier to type than the &#8220;@&#8221; sign.</li>
</ul>


<p>Could we even break some of our typing habits to use such a strange language?</p>

<p>I don&#8217;t have the answers, but I <em>do</em> know that a thirty-year-old keyboard design with mechanical switches and a Scroll Lock key isn&#8217;t what I&#8217;d call revolutionary.</p>

<hr />

<div class="footnotes">
    <ol>
        <li id='fn:1'>Of course, remapping tools could make this easier, and it might be worth looking into, but there&#8217;s something uncomfortable to me about having keys not do what they are labeled to do.  <a href='#fnref:1' rev='footnote'>↩</a></li>
    </ol>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&#10106;&#10144; Inconsistent Architecture]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/08/21/inconsistent-architecture.html"/>
    <updated>2013-08-21T09:32:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/08/21/inconsistent-architecture</id>
    <content type="html"><![CDATA[<p>Quick, which is better: MiniTest or RSpec?  HAML or ERB?  SASS or LESS?</p>

<p>If you are building your first Rails app at your company, it doesn&#8217;t matter.  They all work more or less the same, so just pick one and go.  Take a vote or declare by fiat, but get on with your life.  No project ever failed because they picked HAML over ERB.</p>

<p>If, on the other hand, you are building a new Rails application that runs in an existing technical infrastructure (which is far more likely), then these are the absolute wrong questions to be asking.  Use what your team already uses <em>unless there&#8217;s a good technical reason not to</em>.  Why?</p>

<p>Because consistency is far more important than most other factors.</p>

<!-- more -->


<h2>Consistency is an enabler</h2>

<p>Consistency is the ultimate enabler.  Rails developers should know this better than most, because Rails is built on this very principle.  For example, in Rails, database primary key columns are named <code>ID</code> by default.  This consistency allows Rails to not only make things easier for us, but it also frees us from a pointless debate about naming conventions.  It really doesn&#8217;t matter if the primary key for the <code>ADDRESS</code> table is <code>ID</code> or <code>ADDRESS_ID</code>, but it <em>really</em> matters that all tables use the same naming scheme.</p>

<p>Such consistency enables productivity and agility.  When faced with change, Rails eliminates a large number of decisions we have to make<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.  Need to store some data?  Just choose the name of that data, and Rails handles naming the class and where it will be stored.  Need a new page in your app?  Just choose the name and Rails tells you were to put the code, even generating it for you.</p>

<p>Compare this to an application written using Spring MVC.  Spring is flexible.  It&#8217;s so
flexible.  There are probably 10 ways to map a URL to code, and all of them have equal
complexity.  Which means that your Spring MVC app will be hard to understand and
modify, as each developer maps URLs in their own special way, or you, as the tech lead,
spend an inordinate amount of time reviewing changes and keeping things consistent.
This is time that Rails tech leads don&#8217;t need to spend.</p>

<p>Changes that are constrained to one application aren&#8217;t the most difficult task a
developer faces, however.  As service-oriented architectures become more prevalent,
organizations often require changes that cross application boundaries.  For example,
you may need to move to a publish/subscribe model for performance
reasons, or you might need share views between applications to provide a
unified UI to key decision-makers.</p>

<h2>Cross-Application Changes are Key to Success</h2>

<p>An organization&#8217;s ability to make cross-application changes in the face of changing requirements or business climate can be crucial to staying competitive and successful.  Being unable to make changes can go so far as to sink a company<sup id='fnref:2'><a href='#fn:2' rel='footnote'>2</a></sup>.</p>

<p>Changes across several applications in your architecture are difficult.
They require coordinated changes and consolidation of code, all timed to a
simultaneous release.</p>

<p>Consistency across applications is a force-multiplier for enabling these types of changes.  An Inconsistent Architecture can make these changes unnecessarily difficult, cost-ineffective, or even impossible.</p>

<h2>An Inconsistent Architecture Makes You Slow</h2>

<p>So, if your team has successfully fielded applications, yet is debating &#8220;MiniTest vs. RSpec&#8221;, you&#8217;re blowing it.  You need to be asking, instead, &#8220;What advantage will we gain by introducing this new library?&#8221; and you must also answer the question &#8220;Does this advantage outweigh the negative impact of having an Inconsistent Architecture?&#8221;</p>

<p>Here are some of the negatives:</p>

<ul>
<li>Team in a Constant State of Debate</li>
<li>Cross-Application Work is Taxing</li>
<li>Extraction of Shared Code Difficult</li>
</ul>


<h3>A State of Constant Debate</h3>

<p>Each new application requires a renewed debate about which &#8220;standard libraries&#8221; to use.  Inevitably, this debate also includes the meta-debate about standardization of libraries.  These debates are a waste of time.  Instead of delivering value to your customer or business, you are arguing about significant whitespace and &#8220;clean&#8221; markup.  Your competitors are laughing.</p>

<p>More to the point, however, the constant debate means you cannot develop tooling around application creation and management, because many more decisions are required than if you had a consistent set of agreed-upon libraries and techniques.  This means that the burden of application creation goes up, meaning the value of creating such applications goes down, meaning your business is overall less responsive.</p>

<h3>Cross-Application Work is Taxing</h3>

<p>In an Inconsistent Architecture, each application carriers its own unique set of libraries and microframeworks.  This means that anyone doing cross-application work - difficult enough by its nature - now must contend with several different ways of accomplishing the same thing.  Realistically, no one is going to have deep knowledge of all these tools and libraries.</p>

<p>This means that cross-application work will take longer as the developer in question must head to the documentation much more frequently.  Worse, said developer could simply shoe-horn code for unfamiliar libraries into what they find familiar, making it worse for everyone.</p>

<p>The result is that cross-application work takes longer than it should, and the
resulting code in the relevant applications will be of poorer quality.  A team that has a collective
and deep understanding of fewer tools is going to be more effective than one with only a shallow collective understanding of many tools.</p>

<h3>Extraction of Shared Code Difficult</h3>

<p>Often, cross-application work involves consolidating features according to business or operational requirements.  For example, you might be setting up a centralized user authentication system for all of your applications.  Each application might have slightly different requirements, so your extracted system must meet all of them.</p>

<p>When the code in all these applications is consistent in tooling and approach, this task is much simpler than when a smattering of libraries have been used.  Consider templating languages: even discerning that a template in ERB and one in HAML represent the same thing can be difficult; seeing the differences in order to create a correct shared UI even more-so.</p>

<p>This means the tasks of consolidating code, features, and behavior is now more difficult than they should be - everything must be converted into a common form, rather than simply moved around.</p>

<h2>Is it worth it?</h2>

<p>Having an Inconsistent Architecture carries a lot of negatives.  In <a href="http://www.theseniorsoftwareengineer.com">my book</a>, I have an entire chapter on setting up a new application.  In that
chapter, I talk about the &#8220;blessed stack&#8221;, which is the set of tools, libraries, and frameworks in use at your organization.  For example, at <a href="http://www.stitchfix.com">Stitch Fix</a>, we use Rails, RSpec, ERB, CoffeeScript, Resque, SASS, and Postgres.</p>

<p>The book uses the concept of the &#8220;blessed stack&#8221; as a way to re-frame the decisions you make when creating a new application.  To re-state something from above, if your applications all use SASS, you shouldn&#8217;t be having a &#8220;SASS vs. LESS&#8221; debate, you should be answering the question &#8220;What does LESS bring to the table that makes the pain of inconsistency worth it?&#8221;</p>

<p>The answer is almost always &#8220;nothing&#8221; (for most values of &#8220;SASS&#8221; or &#8220;LESS&#8221;).</p>

<p>That one tool is theoretically &#8220;better&#8221; than another is a discussion for happy hour.  If no standard has been established for a particular need, have a <em>quick</em> debate, and then make a decision (either by fiat or by vote).  Time spent debating is time not <a href="www.theseniorsoftwareengineer.com/focus_on_delivering_results_excerpt.html">delivering results</a>, and your team&#8217;s success does not hinge upon &#8220;clean markup&#8221;.</p>

<h2>But, how do we advance?</h2>

<p>As with the discussion around <a href="http://www.naildrivin5.com/blog/2013/08/08/responsible-refactoring.html">responsible refactoring</a>, there is an
escape hatch to what seems like myopic thinking.  The reading-comprehension-impaired
took away from that post &#8220;never refactor&#8221;, and the same crowd could interpret this
post as &#8220;never use new technology&#8221;.</p>

<p>Both the refactoring and this one revolve around reasons: do you have a good reason to
refactor that code?  OK, great, let&#8217;s do it. At the start of this post, I said that you should use what your team is already using <strong>unless there&#8217;s a good technical reason not to</strong>.</p>

<h2>A Good Technical Reason</h2>

<p>A mature and effective team is always open to debate, but such a team is also
impervious to fallacious arguments.  &#8220;The Rails Way&#8221; is an appeal to authority.
&#8220;Most developers use it&#8221; is an argumentum ad populum (and I&#8217;d be willing to bet you
didn&#8217;t conduct a real study anyway).</p>

<p>Here are some technical reasons (all of which you should be prepared to prove):</p>

<ul>
<li>We can&#8217;t meet our deadlines without library X</li>
<li>The standard won&#8217;t meet our performance requirements</li>
<li>Our default stack is a fundamental mismatch for the problem at hand</li>
<li>We&#8217;re about to lose official support for the status quo/status quo is no longer maintained</li>
<li>This is a low-risk, low-impact project - experimentation might be OK</li>
</ul>


<p>There are probably others more specific to your project, but the point is that you
really should be able to outline <em>why</em> introducing an inconsistency is a net win.
Beware Résumé-Driven-Development.</p>

<p>And, I know this all from experience.  I have been personally responsible for introducing technologies not meeting this burden in two different jobs. I&#8217;m still in contact with some of the developers at both jobs, and these decisions were not a net win, despite whatever problems they may have solved for me in the short-term<sup id='fnref:3'><a href='#fn:3' rel='footnote'>3</a></sup>.</p>

<p>This experience is what brought me to this realization - there&#8217;s nothing like making a
mistake yourself to get clarity on the right way to do things.</p>

<h2>Evolving the Status Quo</h2>

<p>You might feel that working under such a &#8220;regime&#8221; means that you&#8217;ll never learn
anything new, and you&#8217;ll be stuck on the same old version of whatever web framework
you have.</p>

<p>The culture I&#8217;m describing here isn&#8217;t a conservative one, it&#8217;s one that values
consistency.  Understand the difference.</p>

<p>It turns out that a culture of consistency enables technical evolution moreso than one that does not.  When all applications have the same &#8220;shape&#8221;, it becomes markedly easier to move forward with technology choices.</p>

<p>At Stitch Fix, we have currently three Rails apps in production.  The Ruby parts of
them all have a similar shape - the use of controllers, models, and service objects
is fairly similar.  We also have an array of shared gems that have similar shapes as
well.  We use the same libraries across all apps for the most part.</p>

<p>This consistency will make our collective move to Rails 4 a lot smoother than
if every application and gem did things differently.  This will allow one or two
developers to move our team forward with little disruption in service or feature delivery.</p>

<p>If, instead, we&#8217;d fielded a mixture of Rails and Sinatra apps, used different testing
frameworks and different CSS pre-compilers, the task would be orders of magnitude more
difficult.  In this way, a culture of &#8220;use whatever you want&#8221; would actually hold the
organization <em>back</em> from using new technology.  I&#8217;ve worked there.  Twice.  And they
are still dealing with legacy libraries and tools.</p>

<h2>Step-by-Step Instructions</h2>

<p>Here is my ideal approach to technology choice, incredibly summarized (<a href="http://www.theseniorsoftwareengineer.com">the book</a> goes into more detail):</p>

<ol>
<li>Use what you are already using.</li>
<li>If someone wants to deviate, see step 1.</li>
<li>If someone <em>really</em> want to deviate, refuse to debate &#8220;Old vs. New&#8221;.  Refuse.   The
debate <em>must</em> be &#8220;New vs. Consistency&#8221;.  Be open to convincing arguments, and call
out fallacious ones.</li>
<li>If the problem at hand is a new one for your team, quickly choose the new standard so that you never have to make this decision again.  I&#8217;d recommend a brief discussion followed by a vote, with developers writing the code breaking ties, but if you need to decide by fiat, so be it.</li>
<li>Review the &#8220;blessed stack&#8221; periodically.  What&#8217;s working?  What&#8217;s not?  What does
the future look like?  Can you get there?  Be deliberate and not arbitrary in your
technical evolution, but <em>do evolve</em>.  Without this step, the entire thing falls
apart.</li>
</ol>


<p>A younger version of myself would not be into this way of working, so I can understand
if some of you think this is oppressive.  All I can tell you is that it is a pure joy
to solve problems amidst a consistently-architected set of applications, all of which
are themselves internally consistent, despite the technology that makes things
consistent<sup id='fnref:4'><a href='#fn:4' rel='footnote'>4</a></sup>.  Such an
environment is encouraging of problem-solving, which is what I love about programming.
Arguing over <code>describe</code> vs. <code>test</code> seems de minimis now.</p>

<hr />

<div class="footnotes">
    <ol>
        <li id='fn:1'>And you can see very clearly what Rails <strong>doesn&#8217;t</strong> provide by surveying the common debates, for example where business logic goes. <a href='#fnref:1' rev='footnote'>↩</a></li><li id='fn:2'>It can also be very unpleasant working on teams like this, because over time, interesting and high-value projects become impossible, and developers turn into ticket-takers, just pumping out simple features, since they are all that can be reasonably accomplished <a href='#fnref:2' rev='footnote'>↩</a></li><li id='fn:3'>To be fair (to myself), in one of these cases, the team was encouraged to use whatever we wanted for whatever reason, and I bought into it. <a href='#fnref:3' rev='footnote'>↩</a></li><li id='fn:4'>The easiest codebase I ever worked in was in Java, using Spring, because the code was so consistenty designed and written.  Almost every change to it felt like I was merely transcribing business logic. <a href='#fnref:4' rev='footnote'>↩</a></li>
    </ol>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&#10106;&#10144; Responsible Refactoring]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/08/08/responsible-refactoring.html"/>
    <updated>2013-08-08T09:11:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/08/08/responsible-refactoring</id>
    <content type="html"><![CDATA[<p>Emboldened by tests, and with the words &#8220;ruthless refactoring&#8221; in my head, I used to &#8220;improve&#8221; the codebase I was maintaining at a previous job.  One day,
my &#8220;cleanup&#8221; caused production to break.  How could this be?  I was being Agile.  I was Testing.  I was Merciless in my Refactoring.  I had found Code
Smells, dammit!</p>

<p>I was being irresponsible.</p>

<!-- more -->


<p>Lets be clear, first:  I&#8217;m not going to be talking about the third step of the TDD cycle.  Refactoring code that&#8217;s in development and not
currently running on production is something you must absolutely do.  Work clean, and <em>write</em> clean code.  What we&#8217;re talking about is changes to existing,
running code.</p>

<p>In <a href="http://www.naildrivin5.com/blog/2013/06/16/production-is-all-that-matters.html">Production is All That Matters</a>, I outlined the importance of code in production and how to keep it running smoothly.  One thing I
didn&#8217;t touch on was changing that code.  Every change to production introduces a risk of breaking something.  Any system beyond a to-do list or blog
engine has complexity that can be difficult to cover by tests.  Integration tests are brittle, and cross-system tests more so.  Manual QA is the most
brittle of all.</p>

<p>Ideally, the size of your changes to production should be commensurate with the size of the feature you are adding.  Small features should require small
changes.  Large changes should be an indicator of a large or complex feature.</p>

<p>A pure refactoring breaks this rule completely - a refactoring adds no direct business value to the application, yet introduces risk that something will break.</p>

<p>&#8220;But,&#8221; you say, &#8220;refactoring bad code makes it easier to change in the future.  It makes us faster later, and we can deliver more business value then!&#8221;</p>

<p>&#8220;The future&#8221;, you say?  I say <a href="http://en.wikipedia.org/wiki/You_aren't_gonna_need_it">You Ain&#8217;t Gonna Need It</a>, AKA YAGNI.  We tell ourselves not to invent features or add complexity to our code because
we don&#8217;t know what the future holds.  I would say that refactoring outside of the TDD cycle should be viewed in the same light.</p>

<p>How then, do we prevent our code base from rotting?  How can we <em>ever</em> improve it?  If we focus our efforts on demonstrable business value - the future
be damned - how do we avoid having a big pile of shit codebase?</p>

<p>Before we answer, consider a piece of code you&#8217;d like to refactor.  When you see it, it just looks bad.  It&#8217;s hard to follow, has poor naming, and is
generally ugly.  It&#8217;s <em>begging</em> to be cleaned up.  Now suppose that for the next six months, no requirement surfaces, nor bug is found, that requires modifying that code. Is its lack of cleanliness <em>really</em> a problem?</p>

<p>Clean code is not an end unto itself.  Repeat: clean code is not an end unto itself<sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>.</p>

<p>Clean code is a feature of code that is easy to change.  Code that is easy to change enables us to provide value to the business more easily.</p>

<p>Our job isn&#8217;t to write clean code.  Our job isn&#8217;t even to necessarily even write code at all.  It&#8217;s to use software to deliver business value.</p>

<p>With that in mind, let&#8217;s get back to the question at hand: how do we improve our codebase?</p>

<p>When faced with a change we need to make, we form a plan of attack.  This plan may be entirely in our heads, or we might sketch it out, but at some level
we decide how we&#8217;re going to get started.  I would argue that there are at least two ways to tackle every problem:</p>

<ul>
<li>Plow through, making the change as expediently as possible, changing only what&#8217;s needed to ship.</li>
<li>Clean up or improve the code in a way that makes the change easier, then make the change.</li>
</ul>


<p>All you have to do is decide which approach will deliver more value more quickly.  To be honest, it&#8217;s often the first approach, but it&#8217;s not <em>always</em>.
Occasionally, it&#8217;s actually faster to clean things up first.</p>

<p>And <strong>this</strong> is how you improve your codebase. When cleaning up the code <em>enables you to work faster</em> for a task you aren&#8217;t dreaming up but <em>actually have at
hand</em>, refactoring is the way to go.</p>

<p>The beauty of this approach is that you never again need a &#8220;refactoring story&#8221; in your backlog, nor do you need to get &#8220;permission&#8221; to clean up some code.   You simply do it to get your job done faster and better.</p>

<p>Of course, we are bad at estimating, so how can we know what to do?  Here&#8217;s some guidelines that I&#8217;ve found helpful in determining if a refactoring will
help:</p>

<ul>
<li>Changes to public APIs - function, method, module, or class names - are almost never worth it, especially in a dynamically typed language, especially in Ruby but even moreso in JavaScript.</li>
<li>If you have to change a test, it&#8217;s probably not worth it (and not technically a refactoring).</li>
<li>If you&#8217;ll be deleting code, it&#8217;s probably a good sign.</li>
<li>If you are unfamiliar with the code, resist the urge to &#8220;clean it up&#8221; - we often conflate &#8220;I don&#8217;t understand this&#8221; with &#8220;this is poorly designed&#8221;.</li>
</ul>


<p>When you <em>do</em> decide a refactoring is going to help, be sure to put that refactoring in its own commit.  Ideally, get that refactoring up on production in advance
of your change (depending on the significance of your change).  Your tests only tell you what works, not what doesn&#8217;t.  Production can give you more
information.</p>

<p>Pushing your refactoring to production ahead of the actual change also has a nice side-effect: it forces you to consider the risk of the refactoring.  When deciding what to do, if you know your refactoring is going up to production on its own, it allows you to think more clearly about the risk involved in the proposed refactoring.  You may decide it&#8217;s not worth it.</p>

<p>This is what I call <em>responsible refactoring</em>.  Although you don&#8217;t get to go apeshit &#8220;improving&#8221; your codebase, you do get a clear and simple process to make the code better in a way that has demonstrable, immediate benefits.  Think about it next time you are tempted to &#8220;clean up&#8221; some smelly code.</p>

<hr />

<div class="footnotes">
    <ol>
        <li id='fn:1'>It&#8217;s also worth pointing out that the following things are <strong>also</strong> not ends unto themselves: object-orientated, pure functional, immmutabile, referentially transparent, thread safe, O(log n), fast tests, the smallest-sized-CSS-you-can-dream-of, and performance.  I&#8217;m sure I left out about a billion things <a href='#fnref:1' rev='footnote'>↩</a></li>
    </ol>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&dagger; Manual vs Automatic Continuous Deployment]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/08/07/manual-vs-automatic-continuous-deployment.html"/>
    <updated>2013-08-07T12:31:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/08/07/manual-vs-automatic-continuous-deployment</id>
    <content type="html"><![CDATA[<p>My ex-colleague from LivingSocial, <a href="https://twitter.com/danmayer">Dan Mayer</a> posted a <a href="http://mayerdan.com/programming/2013/08/04/thoughts-on-continuous-deployment/">great read about continuous deployment</a>, and the tradeoffs when doing an automatic deploy:</p>

<blockquote><p>After considering some of the real world implications of automated continuous deployment, I didn’t feel it was right for our team on most of our projects at the moment. Both because we would need a bit of additional tooling around deployment and dashboards, and because our tests are far to slow.</p></blockquote>

<p>It&#8217;s a good (and quick) read. Having worked on at least one of the apps that Dan&#8217;s talking about, I would agree he&#8217;s making the right call and that if your test suite is slow, automatic deployment can be a killer.  I also think there&#8217;s a relationship between the size of the contributor group and the speed of the test suite - the more devs pushing stuff in, the faster it has to be.</p>

<p>In <a href="http://www.theseniorsoftwareengineer.com">my book</a>, there&#8217;s a chapter on bootstrapping new applications, and my recommendation is to set up automatic continuous deployment from the start.  I stand by that, because it basically turns the problem Dan identifies around: slow tests slow your deployment which should thus motivate keeping tests slow (and applications lean).  We&#8217;ll see how it works out at <a href="http://stitchfixjobs.com/blog/2013/07/30/our-git-workflow/">Stitch Fix</a>.  We have one app with a somewhat slow test suite, and three with relatively fast ones.  Automatic deploys work really well so far.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&dagger; Stitch Fix Git Workflow]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/07/30/stitch-fix-git-workflow.html"/>
    <updated>2013-07-30T11:04:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/07/30/stitch-fix-git-workflow</id>
    <content type="html"><![CDATA[<p>The Stitch Fix <a href="http://stitchfixjobs.com/blog">tech blog</a> is up, and I just posted <a href="http://stitchfixjobs.com/blog/2013/07/30/our-git-workflow/">how we use Git and Hubot</a> to automate deployment, without having a complex series of
branches and tags.</p>

<blockquote><p>This is fairly simple - new code goes on branches, master is always deployable (when clean), and <code>deploy/production</code> always contains whatever&#8217;s on production.</p></blockquote>

<p><a href="http://www.theseniorsoftwareengineer.com">My book</a> talks about bootstrapping new applications, and my recommendation is to set up continuous deployment.  If you&#8217;ve ever worked on a release
schedule, you&#8217;ll know that continuous deployment is a pure joy.  It&#8217;s also a boon to the users, who get the features and fixes as fast as possible.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[&#10106;&#10144; Agile Email Management]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/07/23/agile-email-management.html"/>
    <updated>2013-07-23T08:27:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/07/23/agile-email-management</id>
    <content type="html"><![CDATA[<p>Email is a fact of life.  It&#8217;s the primary conduit through which all information in our work life flows.  Clients email us.
Users email us.  Project managers email us. Our issue management systems email us.  Heck, even our <em>apps</em> email us when things are going wrong.</p>

<p>Managing email can be tricky - if you spend too much time on it, you don&#8217;t get any other work done, and if you don&#8217;t spend enough
time on it, you appear flaky at best and incompetent at worst.  Over the past several years, I&#8217;ve developed a system for managing
email as a developer that maximizes my responsiveness without creating an undue burden on my workload.  In short, I&#8217;m a lot more
agile in how I deliver results by allowing emails to occasionally &#8220;overrule&#8221; my otherwise prioritized backlog.</p>

<p>I&#8217;m going to share it with you to see if you like it</p>

<!-- more -->


<p>First, we need to understand what is actually coming to us via email.  Emails have many attributes that we&#8217;ll need to use to
figure out what to do:</p>

<ul>
<li>Is the email actionable?</li>
<li>If it is, do I need to take action now?</li>
<li>If not, should someone else take action now?</li>
<li>If not, is this action even worth doing?</li>
</ul>


<p>It&#8217;s actually fairly easy to manage your inbox if you think along these lines.  The key to making it work is the second question,
&#8220;Do I need to take action now?&#8221;  By being honest about your workload and your interpretation of you and your team&#8217;s priorities, you will always be working on what&#8217;s important. You&#8217;ll also transform &#8220;urgent&#8221; (i.e. not urgent) requests into conversations about priorities instead of an ever-growing list of to-dos or a black-hole of unresponsiveness.</p>

<p>The basic process is:</p>

<ol>
<li>Lightly filter unactionable and highly-actionable emails</li>
<li>Read all unread email</li>
<li>Archive unactionable emails</li>
<li>Identify which actionable emails are priorities</li>
<li>Defer all the rest by starting a discussion about priorities</li>
<li>Address priority emails immediately</li>
</ol>


<h2>Lightly filter unactionable and highly-actionable emails</h2>

<p>Ideally, you don&#8217;t get regular emails that can be machine-identified as unactionable.  We don&#8217;t live in the ideal world, so set
up filters for these.  These are emails that you <strong>never</strong> need to read as they come in.  Set your email client to archive - not
delete - these messages.</p>

<p>Second, there are emails that are a requirement for immediate action.  For example, if your website is down.  Configure your
email client to forward these to your cellphone via SMS and <em>leave them as unread</em>.</p>

<p>This is the only filtering you should do.  As we&#8217;ll see, we&#8217;ll be keeping our inbox very clean, and machine-filtering of emails
only serves to hide things from your attention.</p>

<p>Once you&#8217;ve set this up, the remaining emails you receive will require you to read them.</p>

<h2>Read all unread email</h2>

<p>The more frequently you read email, the less you will have to read each time you do so.  I tend to read emails within 15 minutes
of their arrival, however checking once per hour is probably a good place to start.  You should not be &#8220;heads down&#8221; in code for
more than an hour at a time, so this is a good cadence for checking your email.</p>

<p>Each time you check email, read <em>all</em> of it.  You want to establish a Service Level Agreement (SLA) that you read all your emails
at least once per hour (during business hours of course).  This means that any request anyone has of you can get your attention
within 59 minutes.  Doing this reduces the need for others to find you in person, call you on the phone, hit you up on IM or
otherwise interrupt you on <em>their</em> schedule.</p>

<p>Reading email less frequently is an invitation for constant disruption, because anyone who feels their request is urgent will not
want to wait very long for a response.  They are highly likely to wait an hour.</p>

<p>Once you&#8217;ve read your emails, you need to start addressing them before getting back to work.</p>

<h2>Archive all unactionable emails</h2>

<p>Un-actionable emails are emails where the <em>sender</em> agrees that no response is required from you.  This is important.  Just
because <em>you</em> think an email is unactionable, it doesn&#8217;t mean the sender does.  Don&#8217;t passive-aggressively archive emails that are
poorly written or that request information you feel is unimportant.</p>

<p>Once you&#8217;ve identified unactionable emails, archive them.  Never delete your email.  Never.  Delete. Email.  You want to be able
to pull up any email anyone sent you - it&#8217;s an historical record that often clashes with our fallible human memory.</p>

<p>The remaining emails will require you to do <em>something</em>.  This requires prioritization.</p>

<h2>Identify which actionable emails are priorities</h2>

<p>Every email that is actionable must now be prioritized; actionable doesn&#8217;t mean &#8220;do it now&#8221;.  I prefer a modified version of the Merlin Mann School of Priority.
Merlin says that there is only ever one priority - the thing you are working on right now.  I take this one step back and feel that
actions or requests are either a priority or they are not.  There are no relative priorities - just a boolean &#8220;yes&#8221; or &#8220;no&#8221;.</p>

<p>Priority requests are those that require a response within the next 24 hours (accounting for weekends and holidays).  Judge this on your own - if you feel a request is a
priority, then you agree with the sender and can get to it.  If you disagree with the sender, they must convince you - it&#8217;s your
time on the line, so the request isn&#8217;t a priority until you are convinced.</p>

<p>Do not reply to emails that you&#8217;ve identified as priorities.  Since you&#8217;ll be getting to this request quickly, you can simply
deliver one reply when the work is done.  &#8220;I&#8217;m on it&#8221; is not helpful and invites further emails.</p>

<p>Any emails that are <em>not</em> priorities, however,  <em>do</em> require a response.</p>

<h2>Defer all the rest by starting a discussion about priorities</h2>

<p>Requests that aren&#8217;t priorities have a chance of never being done.  Which means that there&#8217;s no guarantee you will ever work on
them.  The sender needs to know this so that they can plan accordingly.  Part of being responsive and reliable is being clear
about what you <em>aren&#8217;t</em> going to be doing.  Since you&#8217;re allowing certain requests to override your current work queue, this
means you get to say &#8220;no&#8221; to things that shouldn&#8217;t.</p>

<p>For requests that you feel are important, but that you don&#8217;t have time for, you have two options:</p>

<ul>
<li>Identify someone else who can do it.  In this case, reply as such and add said person to the email chain</li>
<li>Commit to doing it in the next five days.  If you can&#8217;t commit to this timetable, it&#8217;s probably not that important, so make
this commitment only when you really can get it done.  Don&#8217;t commit farther out, because your accuracy will go <em>way</em> down.</li>
</ul>


<p>For requests you feel are <em>not</em> important (usually because they are not really a priority), you have to let the
requester know.  As briefly and tactfully as possible, lay out your reasons why you won&#8217;t be able to address the request. Include a list of your current priorities - perhaps the requester knows something you don&#8217;t that would change your priorities.</p>

<p>Since this email is going to be &#8220;bad news&#8221; to the sender, it&#8217;s important that you write it well.  There&#8217;s a section in <a href="http://www.theseniorsoftwareengineer.com">my latest book</a> about how do write effective emails, but the short answer is to be concise and read what you write before you send it.</p>

<p>Resist the urge to throw the request into your backlog or feature management system.  Your backlog is a black hole of broken promises and is a
dishonest and passive-aggressive way of dealing with your fellow co-workers&#8217;s requests.  Respect them enough to tell them it&#8217;s not a
priority and that you can&#8217;t realistically guarantee you&#8217;ll ever get to it.  Make <em>them</em> prioritize it - even if by fiat.</p>

<p>Once you reply, archive the original email.  No more action is required on your part unless someone responds.  You&#8217;ll handle
that response the next time you check email.</p>

<p>At this point, your inbox is a short list of emails representing urgent, priority actions, or requests you&#8217;ve agreed to address
in the next five days.  You can differentiate them by the existence of a reply.  Unreplied emails are your priority. Get to them.</p>

<h2>Address priority emails immediately</h2>

<p>Generally, emails either request information or require writing code.  Address the emails requesting information first, as these
are the easiest to deal with.  Find a definitive answer, show how you arrived at it, send the reply, and archive the email.  It&#8217;s
done and out of your life.</p>

<p>Requests that require writing code must now be balanced against your current workload.  I would recommend that bugs that you can
fix in three hours or less you fix immediately.  Your brain is already aligned to the bug by having read and prioritized the
email, so just fix it and get it out of your life.</p>

<p>For everything else, you&#8217;ll have to find a way to deal with it in the next 24 hours.  Work in order based on whatever factors you
feel are important.</p>

<p>Whenever you complete something, reply with your results.  If you are using continuous deployment, reply when the code is on
production.  If you aren&#8217;t, reply when code is in version control scheduled for release, and let the requester know when to
expect the code on production.</p>

<p>After 24 hours, any request you haven&#8217;t addressed deserves a reply.  Your SLA for email <em>responses</em> is 24 hours.  Since you have
no actual result to report, you&#8217;ll need to indicate what the holdup us, and when you can expect to address the issue.</p>

<p>Once your priority requests are addressed, you&#8217;ll need to factor in your &#8220;five-day&#8221; requests into your regular workflow.  Be sure
to circle back to the requester for any issues you haven&#8217;t addressed in five days.  You may need to defer them or delegate them,
but if you find you are frequently unable to deliver on these promises, you need to start promising less of them.</p>

<p>It&#8217;s important that you tailor your promises to match your actual delivered results as much as you can.  Not only does this make
you reliable, but it also allows others to accurately plan based on your availability and existing priorities.  They need - and
deserve - to know that you cannot handle but so much.  Acting as a black  hole makes it very hard for others to do their jobs,
because they don&#8217;t know what you will (and will not) be delivering.</p>

<h2>What this all results in</h2>

<p>It may seem like you&#8217;re going to spend all of your time managing email and addressing the requests therein.  Remember that the key
to this is identifying priorities.  A priority is something you absolutely plan to do in the next 24 hours.  You can only do so
much in that time, especially given everything else you are working on, so it forces you to commit to very little.</p>

<p>The &#8220;five day&#8221; commitment further reinforces this but allowing some flexibility without leading anyone on about what you&#8217;ll
be doing.</p>

<h2>What about my Scrumban Agile Board of Index Cards™?</h2>

<p>I have seen very strict agile processes where the only way to insert work at the top of a developer&#8217;s queue is if something is on
fire and the business is about to go under - everything else goes to the backlog.  This is anything but agile.</p>

<p>If you use a feature management system, it should be used for planned work according to a roadmap resulting from thinking
about solving business problems.  Such planning cannot account for the reality of how a system is built or used.  Over time,
pressure builds from the users of the system against the team&#8217;s plan for its enhancement. Your inbox is a valve to releieve some of
that pressure.  It&#8217;s a way to allow a controlled circumvention of your development process whenever it&#8217;s warranted.</p>

<p>By carefully managing your email, you make yourself (and your team) much more responsive to the reality of the business.  By
promising only what can be delivered in 24 hours, you enable urgent requests to be addressed without becoming lost in a sea of
emails, all while providing honest and useful feedback to your users and co-workers about what can realistically be accomplished.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Senior Software Engineer - My New Book]]></title>
    <link href="http://www.naildrivin5.com/blog/2013/07/15/my-new-book.html"/>
    <updated>2013-07-15T08:00:00-04:00</updated>
    <id>http://www.naildrivin5.com/blog/2013/07/15/my-new-book</id>
    <content type="html"><![CDATA[<p>Last November, I did my own private <a href="http://pragprog.com/news/november-writing-month-pragmatic-guide-to-git-in-print">PragProWriMo</a>, writing every day that month to produce a non-fiction technology book:</p>

<blockquote class="twitter-tweet"><p>And that&#39;s IT! 671 words today for a total of 46,611 words. Now what? Editing hell I guess :) <a href="https://twitter.com/search?q=%23digwrimo&amp;src=hash">#digwrimo</a> <a href="https://twitter.com/search?q=%23PragProWriMo&amp;src=hash">#PragProWriMo</a></p>&mdash; ❺➠ David Copeland (@davetron5000) <a href="https://twitter.com/davetron5000/statuses/274513337486823425">November 30, 2012</a></blockquote>


<script async src="http://www.naildrivin5.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Between Dec 1, 2012 and today, I&#8217;ve been editing it, and it&#8217;s finally complete!</p>

<p><a href="http://www.theseniorsoftwareengineer.com">The Senior Software Engineer</a> is a 200-page e-book on everything a developer needs to know to be a truly senior
engineer…except for how program.</p>

<p>The book&#8217;s subtitle is &#8220;A Guide for Making the Most of Your Career&#8221; and that&#8217;s exactly what it is.  I realized over the past few years
that the best and most successful developers I&#8217;ve come across aren&#8217;t just good at writing code.  They can communicate effectively
with others.  They can launch a greenfield project without incident.  They can write documentation.  They can lead others without
becoming managers who have to give up coding.</p>

<p>In short, these developers prioritize the delivery of results above all else.  They often (though not always) use software to
deliver those results.</p>

<p>This is the subject of the book.  It&#8217;s designed to get you thinking about the big picture, of which computer programs are only a
small part.  It&#8217;s a roadmap for advancing in your career without giving up writing code.</p>

<p>It&#8217;s also prescriptive.  You&#8217;ll learn how to give a code review as well as receive one.  You&#8217;ll learn how to keep organized while
implementing complex features.  You&#8217;ll learn how to create a convincing technical argument by understanding others&#8217; priorities.
You&#8217;ll learn how to interview potential team members, and then lead them to successful product delivery.  <a href="http://www.theseniorsoftwareengineer.com">Check out the website</a>, where you&#8217;ll find a full table of contents as well as some excerpts.</p>

<p>The lessons in this book have taken me a long time to learn, and I still struggle every day with many of them. My hope is
that if we all start thinking about this stuff earlier in our careers (at least as much as we think about the next great language or framework) we can do better work and make software better.</p>

<p><a href="http://www.theseniorsoftwareengineer.com">It&#8217;s available now for $25, in PDF, EPUB, MOBI, and Markdown</a>.  I hope you enjoy it.</p>
]]></content>
  </entry>
  
</feed>
