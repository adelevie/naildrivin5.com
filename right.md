# Doing your best work

If I could sum up the best programmers I've worked with in a sentence, it would be:

> They know what to build and they know how build it

I've only recently come to understand how equally important both are.  As a young engineer, working as a consultant (or at the
bottom of an org-chart), I given things to build and I built them. "Knowing how to build" was all it seemed I needed to know.
Fortunately, getting good at knowing how to build software is straightforward (if time consuming).

The reason is twofold: the more you do something, the better you get at it.  The second reason is that there are tons of
resources on how to write software.  There are tons of tools to help write software, and there are myriad techniques to help
build software quickly and effectively.

Compared to knowing *what* to build, knowing *how* to build something is actually pretty easy.

This is because knowing *what* to build is difficult.

Knowing what software to build requires specialized knowledge beyond software development.  Generically, you have to understand what problem exists that needs solving.  You then have to evaluate all the ways in which that problem could be solved (with or without software).  And then you have to weigh those solutions against a variety of constraints: time, money, chance of success, cost of failure, etc.  

Unlike building software, the processing of deciding *what* to build is not that generalizable.  You have to have specific
knowledge of the domain in question.  My (limited) understanding of the utility industry while working at Opower in no way
prepared me for working at Stitch Fix, where I must understand how a retail business works, as well as how a warehouse operates.

The way most teams deal with this is a separation of duties.  On one side, you have developers who are great at building
software.  On the other are product managers/analysts/whatevers that understand the business domain as well as the specific
business.  And the two teams are intended to work together to solve the problems.

This is a nice idea, but it has practical problems.  The product manager (for lack of a better name) is rarely technical enough
to understand software at a detailed level.  Even when they are (for example, a former developer that moved into product
management), they have no real skin in the game to actually develop the solution.  Whatever decisions they make, it's the
_developers_ that are subject to them.

The developers, lacking an understanding of the business, will propose solutions that aren't appropriate.  Lacking any knowledge
other than building software, developers can tend to suggest solutions that will be more interesting to implement, or engage in
"Resume-Driven Development".  They also may heavily lobby for simple solutions that can be delivered quickly, even if those
solutions aren't ultimately the best for the problem at hand.  Who can blame them?

In these situations, the more each side understands about the other, the better.  Although it's easy to become proficient at
developing software, it's also time-consuming.  This limits the ability of the product manager to have technical insights that
guide their decision-making.

Which brings me back to the best developers I've worked with.  They took the time to understand the problem being solved.  They
took the time to understand what measurable impact a solution might have, and why it was important.  They learned about the
specifics of the business where they worked.

They were doing their best work.  They were engaged with what they were doing.  They delivered results and could point out how
what they did had a positive impact on the organization.

This has an obviously positive impact on the organization, because better solutions get delivered when those building them are
better-informed.   It's also a positive impact for the developers, because they are viewed as partners, not cogs.  They are
viewed as partners because they *act* like partners and therefore *are* partners.   

And with partnership comes trust.  Trust to do the right thing.  Trust that if more time is needed, it really is needed.  Trust
that technical reasons aren't invented but real, and that no more explanation is required.

So how do you get good at this?

The first thing you need to do is to be part of a team whose goals are clearly aligned with the financial goals of the organization you are working for.  This is a *lot* harder than it sounds.  It requires understanding your organization's financial goals, and this is not always easy to understand.

You need to be on a team where you can clearly relate your actions to outcomes for the organization.  What does your team do that
directly relates to the organization's goals?

The simplest way to do this is to work for a product company that sells its product to the product's users.  Think of it  like
building a blog to learn a new web framework.  A company that sells a product directly to users will have a business model that's
easy to understand, and will have clear incentives - will this solution increase or protect revenue?  Will it reduce costs?  

Working for a company like this, the only thing you'll need to learn is the particulars of their line of business.  You don't
need to be an expert, but you need to understand how the company's decision makers make decisions.  Find out what data they look
at it, and figure out where they got it from.

I'm not saying that you can't do your best work at an enterprise software company, a non-profit, or as a consultant.  I'm just
saying that if you want to start getting good at knowing *what* software to build, you want to start off simple.

Whatever you do, start asking yourself (and others), *why* you are building what you are building?  What problem does it solve?
What other solutions were evaluated?  Be curious, and you'll start doing your best work.
